# 對話脈絡介紹：Session、State 與 Memory

## 為什麼脈絡很重要

有意義的多輪對話需要 agent 能夠理解脈絡。就像人類一樣，agent 需要記住對話歷史：已經說過什麼、做過什麼，才能維持連貫性並避免重複。Agent Development Kit (ADK) 提供了結構化的方式，透過 `Session`、`State` 和 `Memory` 來管理這些脈絡。

## 核心概念

你可以將與 agent 的不同對話實例想像成獨立的**對話線程**，這些線程可能會引用**長期知識**。

1.  **`Session`**：目前的對話線程

    *   代表使用者與你的 agent 系統之間*單一且持續進行中的互動*。
    *   包含 agent 在*該次互動*期間，依時間順序的訊息與動作（稱為 `Events`）。
    *   `Session` 也可以儲存僅在*本次對話*期間有效的暫存資料（`State`）。

2.  **`State`（`session.state`）**：目前對話中的資料

    *   儲存在特定 `Session` 內的資料。
    *   用於管理*僅與目前、進行中對話線程*相關的資訊（例如：*本次聊天*中的購物車項目、*本次 session*中提及的使用者偏好）。

3.  **`Memory`**：可搜尋、跨 session 的資訊

    *   代表一個資訊儲存庫，可能涵蓋*多個過去的 session*，或包含外部資料來源。
    *   它作為 agent 可*搜尋*的知識庫，用於回憶超越當前對話的資訊或脈絡。

## 脈絡管理：服務

ADK 提供服務來管理這些概念：

1.  **`SessionService`**：管理不同的對話線程（`Session` 物件）

    *   處理生命週期：建立、擷取、更新（附加 `Events`、修改 `State`）以及刪除個別 `Session`。

2.  **`MemoryService`**：管理長期知識儲存（`Memory`）

    *   處理將資訊（通常來自已完成的 `Session`）匯入長期儲存庫。
    *   提供根據查詢搜尋這些儲存知識的方法。

**實作方式**：ADK 為 `SessionService` 與 `MemoryService` 都提供了多種實作，讓你可以選擇最適合應用需求的儲存後端。值得注意的是，兩種服務都提供了**記憶體內（in-memory）實作**，這些特別適合用於**本地測試與快速開發**。請注意，**所有使用這些記憶體內選項儲存的資料（sessions、state 或長期知識）在應用程式重啟時都會遺失**。若需持久化與可擴展性超越本地測試，ADK 也提供雲端與資料庫服務選項。

**總結：**

*   **`Session` & `State`**：專注於**當前互動**——*單一、進行中對話*的歷史與資料。主要由 `SessionService` 管理。
*   **Memory**：專注於**過去與外部資訊**——一個*可搜尋的資料庫*，可能跨越多個對話。由 `MemoryService` 管理。

## 接下來？

在接下來的章節，我們將更深入探討這些元件：

*   **`Session`**：了解其結構與 `Events`。
*   **`State`**：如何有效讀取、寫入及管理 session 專屬資料。
*   **`SessionService`**：如何為你的 session 選擇合適的儲存後端。
*   **`MemoryService`**：探索儲存與擷取更廣泛脈絡的選項。

理解這些概念是打造能夠進行複雜、有狀態且具脈絡感知對話 agent 的基礎。
