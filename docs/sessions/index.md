# 對話情境介紹：Session、State 與 Memory

## 為什麼情境很重要

有意義的多輪對話需要 agent 能夠理解情境。就像人類一樣，agent 需要記住對話歷史：已經說過什麼、做過什麼，才能維持連貫性並避免重複。Agent Development Kit (ADK) 提供了結構化的方式，透過 `Session`、`State` 和 `Memory` 來管理這些情境。

## 核心概念

你可以將與 agent 的不同對話實例想像成獨立的**對話線程**，這些線程有時會引用**長期知識**。

1.  **`Session`**：當前對話線程

    *   代表使用者與你的 agent 系統之間*單一且持續進行中的互動*。
    *   包含 agent 在*該次互動*期間，依時間順序產生的訊息與動作（稱為 `Events`）。
    *   `Session` 也可以保存僅*在本次對話期間*有效的暫存資料（`State`）。

2.  **`State`（`session.state`）**：當前對話中的資料

    *   儲存在特定 `Session` 內的資料。
    *   用來管理*僅與目前這條對話線程*相關的資訊（例如：*本次聊天*中的購物車項目、*本次 session*中提及的使用者偏好）。

3.  **`Memory`**：可搜尋、跨 Session 的資訊

    *   代表一個資訊儲存區，可能涵蓋*多個過去的 session*，或包含外部資料來源。
    *   它就像 agent 可用來*搜尋*、回憶超越當前對話範圍的資訊或情境的知識庫。

## 情境管理：服務

ADK 提供服務來管理這些概念：

1.  **`SessionService`**：管理不同的對話線程（`Session` 物件）

    *   處理生命週期：建立、取得、更新（新增 `Events`、修改 `State`），以及刪除個別 `Session`。

2.  **`MemoryService`**：管理長期知識儲存（`Memory`）

    *   處理將資訊（通常來自已結束的 `Session`）匯入長期儲存區。
    *   提供根據查詢搜尋這些已儲存知識的方法。

**實作方式**：ADK 為 `SessionService` 和 `MemoryService` 都提供了不同的實作選擇，讓你可以根據應用需求選擇最合適的儲存後端。特別值得一提的是，兩種服務都提供了**記憶體內（in-memory）實作**，這些設計專為**本機測試與快速開發**而打造。請注意，**所有使用這些記憶體內選項（sessions、state 或長期知識）儲存的資料，在應用程式重新啟動時都會遺失**。若需持久化與可擴展性超越本機測試，ADK 也提供雲端及資料庫服務選項。

**總結：**

*   **`Session` & `State`**：聚焦於**當前互動**——*單一、主動對話*的歷史與資料。主要由 `SessionService` 管理。
*   **Memory**：聚焦於**過去與外部資訊**——*可搜尋的歸檔*，可能跨越多次對話。由 `MemoryService` 管理。

## 接下來？

在接下來的章節中，我們將更深入探討這些元件：

*   **`Session`**：理解其結構與 `Events`。
*   **`State`**：如何有效讀取、寫入與管理 session 專屬資料。
*   **`SessionService`**：為你的 session 選擇合適的儲存後端。
*   **`MemoryService`**：探索儲存與取得更廣泛情境的選項。

理解這些概念，是打造能夠進行複雜、有狀態且具情境感知對話 agent 的基礎。
